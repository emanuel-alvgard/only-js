<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>frontend</title>
</head>
<body>

    <div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>

    <script>

        // ASSETS
        // load all assets and only use references in views and sounds.

    
        let fonts = {
            target: 3,
            loaded: 0,
        }

        let roboto_400 = new FontFace("roboto_400", "url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxK.woff2)");
        let roboto_mono_700 = new FontFace("roboto_mono_700", "url(https://fonts.gstatic.com/s/robotomono/v21/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_Of2_ROW4.woff2)");
        let libre_bodoni_700 = new FontFace("libre_bodoni_700", "url(https://fonts.gstatic.com/s/librebodoni/v2/_Xm--H45qDWDYULr5OfyZudXzSBgY2oMBGte6GpY8WvTcQ.woff2)");
        async function font(f, r) {
            await f.load();
            document.fonts.add(f);
            r.loaded += 1;
        }

        font(roboto_400, fonts);
        font(roboto_mono_700, fonts);
        font(libre_bodoni_700, fonts);

        let time = performance.now();
        let delta = 0;


        // @DONE
        function init_dom() {
            
            let dom = { 
                load: 1,
                
                width: document.documentElement.clientWidth,
                height: document.documentElement.clientHeight,
                
                h: document.head,
                b: document.body,
                e: [] 
            }

            dom.b.style.margin = "0px";
            dom.b.style.padding = "0px";
            dom.b.style.left = "0px";
            dom.b.style.top = "0px";
            dom.b.style.overflow = "hidden";

            let p = document.body.children[0];
            let c = p.children;
            dom.e.push(p);
            
            for (let i = 0; i < c.length; i++) {
                dom.e.push(c[i]);
            }
            for (let i = 0; i < dom.e.length; i++) {
                dom.e[i].style.position = "absolute";
                dom.e[i].style.margin = "0px";
                dom.e[i].style.padding = "0px";
                dom.e[i].style.border = "none";
                dom.e[i].style.left = "0px";
                dom.e[i].style.top = "0px";
                dom.e[i].style.width = "0px";
                dom.e[i].style.height = "0px";
                dom.e[i].style.zIndex = "0";
                dom.e[i].style.overflow = "hidden";
                dom.e[i].style.overflowWrap = "break-word";
            }

            return dom;
        }

        // FLOAT
        let x0 = 0; // position
        let x1 = 1; // dimension
        let x2 = 2; // rotation
        let x3 = 3; // scale

        let y0 = 4;
        let y1 = 5;
        let y2 = 6;
        let y3 = 7;

        let z0 = 8;
        let z1 = 9;
        let z2 = 10;
        let z3 = 11;

        let opac = 12;
        let bl = 13;
        let cont = 14;
        let satu = 15;
        let gray = 16;
        let brig = 17;
        let sepi = 18;

        let red = 19;
        let green = 20;
        let blue = 21;

        let t_red = 22;
        let t_green = 23;
        let t_blue = 24;
        let t_size = 25;

        // STRING
        let text = 0;
        let t_align = 1;
        let t_font = 2;

        // @ADD clip-path properties

        function fill_array(a, b) {
            for (let i = 0; i < a.length; i++) {
                a[i] = b;
            }
        }
        
        // @HERE 
        function init_type(size, floats, strings) {

            let t = {
                
                state: new Int32Array(size), // change to event?
                render: new Int8Array(size), 

                // FLOAT
                f32_s: [], // property state
                f32_c: [], // property current frame
                f32_p: [], // property previous frame

                // LOCK NUMBER
                loa: [], // active
                lot: [], // type
                lopr: [], // property
                lota: [], // target
                loof: [], // offset
                lomi: [], // min
                loma: [], // max

                lodp: [], // defer property
                lodt: [], // defer target

                // ANIMATE NUMBER
                // Static
                ast: [], // start
                aen: [], // end
                ati: [], // time
                ade: [], // delay
                acu: [], // curve
                aev: [], // event

                // Dynamic
                aa: [], // active
                ar: [], // running
                ae: [], // event
                ap: [], // progress
                at: [], // timer
                as: [], // sample

                // STRING
                str_s: [],
                str_c: [],
                str_p: []
            }

            fill_array(t.render, 1);

            // FLOAT
            for (let i = 0; i < floats; i++) {
                
                t.f32_s.push(new Int8Array(size));
                t.f32_c.push(new Float32Array(size));
                t.f32_p.push(new Float32Array(size));

                // LOCK
                t.loa.push(new Int8Array(size));
                t.lot.push(new Array(size));
                t.lopr.push(new Int8Array(size));
                t.lota.push(new Int32Array(size));
                t.loof.push(new Float32Array(size));
                t.lomi.push(new Float32Array(size));
                fill_array(t.lomi[i], -1);
                t.loma.push(new Float32Array(size));
                fill_array(t.loma[i], -1);
                
                t.lodp.push(new Int32Array(size));
                t.lodt.push(new Int32Array(size));
                fill_array(t.lodp[i], -1);
                fill_array(t.lodt[i], -1);

                // ANIMATION
                t.ast.push(new Float32Array(size));
                t.aen.push(new Float32Array(size));
                t.ati.push(new Float32Array(size));
                t.ade.push(new Int32Array(size));
                t.acu.push(new Array(size));
                t.aev.push(new Int32Array(size));
                
                t.aa.push(new Int8Array(size));
                t.ar.push(new Int8Array(size));
                t.ae.push(new Int8Array(size));
                t.ap.push(new Float32Array(size));
                t.at.push(new Float64Array(size));
                t.as.push(new Int32Array(size));
            }

            // STRING
            for (let i = 0; i < strings; i++) {
                t.str_s.push(new Array(size));
                fill_array(t.str_s[i], "");
                t.str_c.push(new Array(size));
                fill_array(t.str_c[i], "");
                t.str_p.push(new Array(size));
                fill_array(t.str_p[i], "");
            }

            return t;
        }






        // INIT
        let dom = init_dom();
        //let audio = init_audio();
        
        // VEIWS
        let v = init_type(dom.e.length, 26, 3);

        // TRANSFORM
        fill_array(v.f32_c[x3], 1.0);
        fill_array(v.f32_c[y3], 1.0);
        fill_array(v.f32_c[z3], 1.0);
            
        // FILTER
        fill_array(v.f32_c[opac], 100.0);
        fill_array(v.f32_c[cont], 100.0);
        fill_array(v.f32_c[satu], 100.0);
        fill_array(v.f32_c[brig], 100.0);

        // SOUNDS
        //let s = init_type(audio.e.length, 0, 0);

        // BOUNDS
        //let b = init_type(10, 6, 0);

        // audio test

        let test = new AudioContext;
        let oc = test.createOscillator();
        oc.type = "triangle";
        oc.frequency = 100;
        oc.connect(test.destination);
        oc.start();
        dom.e[2].addEventListener("mousedown", function() {
            test.resume();
        });
        dom.e[2].addEventListener("mouseup", function() {
            test.suspend();
        });

        let audio = 0; 
        let frequency = 1;
        let volume = 2;
        let speed = 3;






        // GET VALUE
        // @
        function num(t, s, p) { 
            if (t.loa[p][s] === 1) {
                // resolve lock
            }    
            return t.f32_c[p][s]; 
        }

        function str(t, i, p) { return t.str_c[p][i]; }

        // SET VALUE
        function _num(t, i, p, j) { t.f32_c[p][i] = j; }
        function _str(t, i, p, j) { t.str_c[p][i] = j; }

        // GET STATE
        function num_(t, i, p) { return t.f32_s[p][i]; }
        function str_(t, i, p) { return t.str_s[p][i]; }




        // @DONE
        function lock(st, su, sp, tt, ta, tp, offset, min, max) {
            st.loa[sp][su] = 1;
            st.lot[sp][su] = tt;        
            st.lopr[sp][su] = tp;
            st.lota[sp][su] = ta;
            st.loof[sp][su] = offset;
            st.lomi[sp][su] = min;
            st.loma[sp][su] = max;
            return;
        }

        // @DONE
        function _lock(t, su, sp) {
            t.loa[sp][su] = 0; 
            return;
        }

        // @DONE
        function update_locks(t) {
            
            let defer = 0;
            
            for (let i = 0; i < t.loa.length; i++) {
                for (let j = 0; j < t.loa[i].length; j++) {
                    if (t.loa[i][j] === 0) { continue; } // ACTIVE
                    if (i < t.lopr[i][j]) { t.lodp[defer] = i; t.lodt[defer] = j; defer += 1; continue; } // DEFER
                    t.f32_c[i][j] = t.lot[i][j].f32_c[t.lopr[i][j]][t.lota[i][j]] + t.loof[i][j]; // SET VALUE
                    if (t.lomi[i][j] !== -1 && t.f32_c[i][j] < t.lomi[i][j]) { t.f32_c[i][j] = t.lomi[i][j]; } // MIN
                    else if (t.loma[i][j] !== -1 && t.f32_c[i][j] > t.loma[i][j]) { t.f32_c[i][j] = t.loma[i][j]; } // MAX
                }
            }

            // DEFER
            for (let d = (defer - 1); d >= 0; d--) {
                
                let i = t.lodp[d];
                let j = t.lodt[d];
                
                t.f32_c[i][j] = t.lot[i][j].f32_c[t.lopr[i][j]][t.lota[i][j]] + t.loof[i][j]; // SET VALUE
                if (t.lomi[i][j] !== -1 && t.f32_c[i][j] < t.lomi[i][j]) { t.f32_c[i][j] = t.lomi[i][j]; } // MIN
                else if (t.loma[i][j] !== -1 && t.f32_c[i][j] > t.loma[i][j]) { t.f32_c[i][j] = t.loma[i][j]; } // MAX
                
                // RESET DEFER
                t.lodp[d] = -1;
                t.lodt[d] = -1;
            }
            
            return;
        }

        // @DONE
        function lerp(p0, p1, i) {
            return ((p1 - p0) * i) + p0; 
        }

        // @DONE
        function quad(p0, p1, p2, i) {
            let l0 = lerp(p0, p1, i);
            let l1 = lerp(p1, p2, i);
            return lerp(l0, l1, i);
        }

        // @DONE
        function cube(p0, p1, p2, p3, i) {
            let q0 = quad(p0, p1, p2, i);
            let q1 = quad(p1, p2, p3, i);
            return lerp(q0, q1, i);
        }

        // @
        function anim(t, s, p, start, end, time, delay, curve, event) {

            t.ast[p][s] = start;
            t.aen[p][s] = end;
            t.ati[p][s] = time;
            t.ade[p][s] = delay;
            t.acu[p][s] = curve;
            t.aev[p][s] = event;
            
            t.aa[p][s] = 1;
            t.ar[p][s] = 1;
            t.ae[p][s] = 0;
            t.ap[p][s] = 0.0;
            t.at[p][s] = 0.0 - delay;
            t.f32_c[p][s] = start;
        }

        function _anim(t, s, p) {
            if (t.aa[p][s] === 1) { t.aa[p][s] = 0; }
            else { t.aa[p][s] = 1; }
        }

        // @DONE
        function update_anims(t) {

            for (let i = 0; i < t.ar.length; i++) {
                for (let j = 0; j < t.ar[i].length; j++) {

                    if (t.aa[i][j] === 0 || t.ar[i][j] === 0) { continue; }
                    
                    // INVERT
                    let dir = 1;
                    let st = t.ast[i][j];
                    let en = t.aen[i][j];
                    if (en < st) { st = t.aen[i][j]; en = t.ast[i][j]; dir = -1; }
                    let di = en - st;

                    // CALCULATE
                    t.at[i][j] += delta;
                    if (t.at[i][j] < 0) { continue; }
                    let cr = 0;
                    if (t.acu[i][j].length === 2) { cr = lerp(t.acu[i][j][0], t.acu[i][j][1], t.at[i][j] / (t.ati[i][j] + delta)); } 
                    else if (t.acu[i][j].length === 3) { cr = quad(t.acu[i][j][0], t.acu[i][j][1], t.acu[i][j][2], t.at[i][j] / (t.ati[i][j] + delta)); }
                    else if (t.acu[i][j].length === 4) { cr = cube(t.acu[i][j][0], t.acu[i][j][1], t.acu[i][j][2], t.acu[i][j][3], t.at[i][j] / (t.ati[i][j] + delta)); }
                    let pr = ((di / t.ati[i][j]) * cr) * delta;
                    t.ap[i][j] += pr;
                    t.f32_c[i][j] += (pr * dir);

                    // DONE
                    if (t.ap[i][j] >= di || t.at[i][j] >= t.ati[i][j] + delta) { 
                        t.f32_c[i][j] = t.aen[i][j];
                        t.aa[i][j] = 0;
                        t.ar[i][j] = 0;
                        t.ae[i][j] = t.aev[i][j];
                    }
                }
            }
        }

        // @DONE
        function clear_anims(t) {
            for (let i = 0; i < t.ae.length; i++) {
                for (let j = 0; j < t.ae[i].length; j++) {
                    t.ae[i][j] = 0;
                }
            }
        }


        function round(n) {
            return n + (n>0?0.5:-0.5) << 0;
        }


        function update_dom(dom) {

            let i = 0;
            let len = dom.e.length;

            // RENDER
            while (i < len) {
                if (v.f32_c[x0][i] > (dom.width + 100.0)) { v.render[i] = 0; }
                else if (v.f32_c[y0][i] > (dom.height + 100.0)) { v.render[i] = 0; }
                else if (v.f32_c[x1][i] < -100.0) { v.render[i] = 0; }
                else if (v.f32_c[y1][i] < -100.0) { v.render[i] = 0; }
                i += 1;
            }

            // TRANSFORM 
            i = 0;
            while (i < len) {
                
                let update = 0;

                if (v.f32_c[x0][i] !== v.f32_p[x0][i]) { update = 1; }
                else if (v.f32_c[y0][i] !== v.f32_p[y0][i]) { update = 1; }
                else if (v.f32_c[z2][i] !== v.f32_p[z2][i]) { update = 1; } 
                else if (v.f32_c[x3][i] !== v.f32_p[x3][i]) { update = 1; }   
                
                if (update === 1 && v.render[i] === 1) {
                    dom.e[i].style.transform = 
                        "translate(" + v.f32_c[x0][i] + 
                        "px, " + v.f32_c[y0][i] + "px) " + 
                        "rotate(" + v.f32_c[z2][i] + "deg)" + 
                        "scale(" + v.f32_c[x3][i] + ", " + v.f32_c[y3][i] + ")";
                } 
                i += 1; 
            } 
            
            // WIDTH
            i = 0;
            while (i < len) { 
                if ((v.f32_c[x1][i] - v.f32_c[x0][i]) !== (v.f32_p[x1][i] - v.f32_p[x0][i])) {
                    dom.e[i].style.width = (v.f32_c[x1][i] - v.f32_c[x0][i]) + "px";
                }
                i += 1;
            } 
            
            // HEIGHT
            i = 0;
            while (i < len) {
                if ((v.f32_c[y1][i] - v.f32_c[y0][i]) !== (v.f32_p[y1][i] - v.f32_p[y0][i])) { 
                    dom.e[i].style.height = (v.f32_c[y1][i]- v.f32_c[y0][i]) + "px";
                } 
                i += 1;
            } 
            
            // FILTER
            i = 0;
            while (i < len) {
                
                let update = 0;
                let opacity = "";
                let blur = "";
                let contrast = "";
                let saturate = "";
                let grayscale = "";
                let brightness = "";
                let sepia = "";

                if (v.f32_c[opac][i] !== v.f32_p[opac][i]) { opacity = "opacity(" + v.f32_c[opac][i] + "%) "; update = 1; }
                if (v.f32_c[bl][i] !== v.f32_p[bl][i]) { blur = "blur(" + v.f32_c[bl][i] + "px) "; update = 1; }
                if (v.f32_c[cont][i] !== v.f32_p[cont][i]) { contrast = "contrast(" + v.f32_c[cont][i] + "%) "; update = 1; }
                if (v.f32_c[satu][i] !== v.f32_p[satu][i]) { saturate = "saturate(" + v.f32_c[satu][i] + "%) "; update = 1; }
                if (v.f32_c[gray][i] !== v.f32_p[gray][i]) { grayscale = "grayscale(" + v.f32_c[gray][i] + "%) "; update = 1; }
                if (v.f32_c[brig][i] !== v.f32_p[brig][i]) { brightness = "brightness(" + v.f32_c[brig][i] + "%) "; update = 1; }
                if (v.f32_c[sepi][i] !== v.f32_p[sepi][i]) { sepia = "sepia(" + v.f32_c[sepi][i] + "%) "; update = 1; }
                if (update === 1) { dom.e[i].style.filter = opacity + blur + contrast + saturate + grayscale + brightness + sepia; }    
                i += 1; 
            }
            
            // BACKGROUND COLOR
            i = 0;
            while (i < len) {
                let update = 0;
                if (v.f32_c[red][i] !== v.f32_p[red][i]) { update = 1; }
                if (v.f32_c[green][i] !== v.f32_p[green][i]) { update = 1; }
                if (v.f32_c[blue][i] !== v.f32_p[blue][i]) { update = 1; }
                if (update === 1) { 
                    dom.e[i].style.backgroundColor =
                        "rgb(" + 
                        v.f32_c[red][i] + "," +
                        v.f32_c[green][i] + "," +
                        v.f32_c[blue][i] + ")";
                }
                i += 1;
            }

            // TEXT
            i = 0;
            while (i < len) { 
                if (v.str_c[text][i] !== v.str_p[text][i]) {
                    dom.e[i].textContent = v.str_c[text][i];
                }
                i += 1;
            }

            // TEXT ALIGN
            i = 0;
            while (i < len) {
                if (v.str_c[text][i] === "") { i += 1; continue; }
                if (v.str_c[t_align][i] !== v.str_p[t_align][i]) { 
                    dom.e[i].style.textAlign = v.str_c[t_align][i];
                }
                i += 1;
            }

            // TEXT FONT
            i = 0;
            while (i < len) {
                if (v.str_c[text][i] === "") { i += 1; continue; }
                if (v.str_c[t_font][i] !== v.str_p[t_font][i]) { 
                    dom.e[i].style.fontFamily = v.str_c[t_font][i];
                }
                i += 1;
            }

            // TEXT COLOR
            i = 0;
            while (i < len) {
                if (v.str_c[text][i] === "") { i += 1; continue; }
                let update = 0;
                if (v.f32_c[t_red][i] !== v.f32_p[t_red][i]) { update = 1; }
                if (v.f32_c[t_green][i] !== v.f32_p[t_green][i]) { update = 1; }
                if (v.f32_c[t_blue][i] !== v.f32_p[t_blue][i]) { update = 1; }
                if (update === 1) { 
                    dom.e[i].style.color =
                        "rgb(" + 
                        v.f32_c[t_red][i] + "," +
                        v.f32_c[t_green][i] + "," +
                        v.f32_c[t_blue][i] + ")";
                }
                i += 1;
            }

            // TEXT SIZE
            i = 0;
            while (i < len) {
                if (v.str_c[text][i] === "") { i += 1; continue; }
                if (v.f32_c[t_size][i] !== v.f32_p[t_size][i]) { 
                    dom.e[i].style.fontSize = v.f32_c[t_size][i] + "px";
                }
                i += 1;
            }

            fill_array(v.render, 1);

            // SHADOW

            // CLEAR EVENTS
            dom.load = 0;
        }

        function clear_dom(dom) {}


        function update_views(rt) {

            let viewport = 0;
            let header = 1;
            let card = 2;
            let card_bot = 3;
            let card_title = 4;

            _num(v, viewport, x1, rt.width);
            _num(v, viewport, y1, rt.height);

            let curve_line = [0.0, 2.0];
            let curve_quad = [3.0, 0.0, 0.0];
            let curve_cube = [2.5, 1.0, 0.5, 0.0];

            // FIRST LOAD
            if (rt.load === 1) {
                v.f32_c[x0][card] = 300;
                rt.e[card].style.borderStyle = "none";
                rt.e[card].style.borderRadius = "15px";
                //rt.e[card].style.boxShadow = "0px 0.5px 7px rgb(175, 175, 175)";

                rt.e[card_bot].style.borderStyle = "none";
                rt.e[card_bot].style.borderRadius = "0px 0px 15px 15px";
                rt.e[card_bot].style.backgroundColor = "rgb(100, 100, 100)";

                rt.e[header].style.borderStyle = "none";
                rt.e[header].style.boxShadow = "0px 0.5px 7px rgb(175, 175, 175)";



                _str(v, card_title, text, "this is a test to see if it works like expected. Well it seems to be working somewhat.");
                _str(v, card_title, t_align, "center");
                _str(v, card_title, t_font, "roboto_400");

                //_num(v, card_title, red, 200);
                //_num(v, card_title, green, 0);
                //_num(v, card_title, blue, 0);

                _num(v, card, red, 200);
                _num(v, card, green, 200);
                _num(v, card, blue, 200);
                _num(v, card, y0, 200);

                // LAYOUT
                lock(v, card_title, x0, v, card, x0, 25, -1, -1);
                lock(v, card_title, x1, v, card, x1, -25, -1, -1);
                lock(v, card_title, y0, v, card_title, y1, -60, -1, -1);
                lock(v, card_title, y1, v, card, y0, -25, -1, -1);

                //lock(v, card, y0, viewport, y0, 300, -1, -1);
                lock(v, card, x1, v, card, x0, 300, -1, -1);
                lock(v, card, y1, v, card, y0, 500, -1, -1);

                
                lock(v, card_bot, x0, v, card, x0, 0, -1, -1);
                lock(v, card_bot, x1, v, card, x1, 0, -1, -1);
                lock(v, card_bot, y1, v, card, y1, 0, -1, -1);
                

                lock(v, header, x1, v, viewport, x1, 0, -1, -1);
                lock(v, header, y1, v, viewport, y0, 100, -1, -1);

                anim(v, card, x0, 200, 500, 3000, 500, curve_quad, 2);
                anim(v, card_title, opac, 0, 100, 3000, 500, curve_quad, 0);
                anim(v, card_bot, blue, 100, 200, 2000, 500, curve_quad, 0);
            }

            
            if (v.ae[y0][card] === 1) { 
                anim(v, card, x0, 200, 500, 2000, 500, curve_quad, 2);
                anim(v, card_title, opac, 0, 100, 2000, 500, curve_quad, 0);
                anim(v, card_bot, blue, 100, 200, 2000, 500, curve_quad, 0);
            }
            else if (v.ae[x0][card] === 2) { 
                anim(v, card, y0, 200, 500, 2000, 500, curve_quad, 3);
                anim(v, card_title, opac, 100, 0, 2000, 500, curve_quad, 0);
                anim(v, card_bot, green, 100, 200, 2000, 500, curve_quad, 0);
            }
            else if (v.ae[y0][card] === 3) { 
                anim(v, card, x0, 500, 200, 2000, 500, curve_quad, 4);
                anim(v, card_title, opac, 0, 100, 2000, 500, curve_quad, 0);
                anim(v, card_bot, red, 100, 200, 2000, 500, curve_quad, 0);
            }
            else if (v.ae[x0][card] === 4) { 
                anim(v, card, y0, 500, 200, 2000, 500, curve_quad, 1);
                anim(v, card_title, opac, 100, 0, 2000, 500, curve_quad, 0);
            }

            update_locks(v);
            
            // @ADD
            // make so that get function takes locks into account
            let a = (num(v, card, y1) - num(v, card, y0)) / 2;
            lock(v, card_bot, y0, v, card, y0, a, -1, -1);

            clear_anims(v);
            update_anims(v);
            update_locks(v);
        }

        function clear_views() {
            
            // FLOAT
            for (let i = 0; i < v.f32_c.length; i++) {
                for (let j = 0; j < v.f32_c[i].length; j++) { 
                    if (v.f32_c[i][j] !== v.f32_p[i][j]) { v.f32_p[i][j] = v.f32_c[i][j]; }
                }
            }

            // STRING
            for (let i = 0; i < v.str_c.length; i++) {
                for (let j = 0; j < v.str_c[i].length; j++) { 
                    if (v.str_c[i][j] !== v.str_p[i][j]) { v.str_p[i][j] = v.str_c[i][j]; }
                }
            }
        }

        function main() {

            // @INVESTIGATE
            dom.width = document.documentElement.clientWidth;
            dom.height = document.documentElement.clientHeight;

            let new_time = performance.now();
            delta = new_time - time;
            time = new_time;
            
            if (fonts.loaded === fonts.target) {
                update_views(dom);
                update_dom(dom);
                clear_views();
                clear_dom(dom);
            }

            window.requestAnimationFrame(main);

        }

        main();
        
    </script>
</body>
</html>